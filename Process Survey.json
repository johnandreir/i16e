{
  "name": "Process Survey",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Extract entity data using the same logic as Calculate Metrics\n// Handle array of DPE objects from trigger\nlet entityValues = [];\nlet action = 'processSurvey';\nlet entityType = 'dpe';\nlet entityName = 'Unknown';\nlet totalEntities = 0;\n\ntry {\n  console.log('=== PROCESS SURVEY - EXTRACT ENTITY DEBUG ===');\n  console.log('üöÄ Processing trigger data for DPE array (same as Calculate Metrics)');\n  \n  // Try multiple ways to access the trigger data\n  let triggerData = null;\n  \n  // Method 1: Get first item (might be just one item of array)\n  try {\n    const method1 = $input.first().json;\n    console.log('üìã Method 1 - first().json:', JSON.stringify(method1, null, 2));\n    console.log('üìã Method 1 - Type:', typeof method1, 'IsArray:', Array.isArray(method1));\n    triggerData = method1;\n  } catch (e) {\n    console.log('‚ùå Method 1 failed:', e.message);\n  }\n  \n  // Method 2: Get all items (might be multiple items)\n  try {\n    const method2 = $input.all();\n    console.log('üìã Method 2 - all() length:', method2.length);\n    if (method2.length > 0) {\n      console.log('üìã Method 2 - all()[0]:', JSON.stringify(method2[0].json, null, 2));\n      if (method2.length > 1) {\n        console.log('üìã Method 2 - all()[1]:', JSON.stringify(method2[1].json, null, 2));\n      }\n      \n      // If we have multiple trigger items, combine them into array\n      if (method2.length > 1) {\n        triggerData = method2.map(item => item.json);\n        console.log('‚úÖ Method 2 - Combined multiple trigger items into array');\n      } else if (method2.length === 1) {\n        triggerData = method2[0].json;\n        console.log('‚úÖ Method 2 - Using single trigger item');\n      }\n    }\n  } catch (e) {\n    console.log('‚ùå Method 2 failed:', e.message);\n  }\n  \n  console.log('üìã Final trigger data type:', typeof triggerData);\n  console.log('üìã Final trigger data isArray:', Array.isArray(triggerData));\n  console.log('üìã Final trigger data:', JSON.stringify(triggerData, null, 2));\n  \n  // Handle the array format: [{ entityValue, owner_full_name, ... }, ...]\n  if (Array.isArray(triggerData)) {\n    console.log('‚úÖ Detected array format with', triggerData.length, 'DPE objects');\n    \n    // Extract entity values and create inputData in the same format as Calculate Metrics\n    const inputData = triggerData.map((dpeObj, index) => {\n      const name = dpeObj.entityValue || dpeObj.owner_full_name;\n      console.log(`üìù DPE ${index + 1}: ${name}`);\n      return {\n        entityValue: name,\n        owner_full_name: name,\n        entityType: dpeObj.entityType || 'dpe',\n        entityName: dpeObj.entityName || name,\n        entityIndex: index,\n        totalEntities: triggerData.length,\n        source: 'process-survey-trigger'\n      };\n    }).filter(item => item.entityValue);\n    \n    // Get metadata from first object (all should have same metadata)\n    if (triggerData.length > 0) {\n      const firstDpe = triggerData[0];\n      action = 'processSurvey';\n      entityType = firstDpe.entityType || 'squad';\n      entityName = firstDpe.entityName || 'Unknown Squad';\n      totalEntities = firstDpe.totalEntities || triggerData.length;\n    }\n    \n    console.log('üìä Extracted from array:', {\n      inputDataLength: inputData.length,\n      entityType,\n      entityName,\n      totalEntities,\n      action\n    });\n    \n    return [{ \n      json: { \n        inputData: inputData,\n        processedCount: 0,\n        totalInputs: inputData.length,\n        timestamp: new Date().toISOString(),\n        source: 'process-survey-extract-entity',\n        entityType: entityType,\n        entityName: entityName,\n        action: action\n      } \n    }];\n  }\n  // Handle single object format (fallback)\n  else if (triggerData && typeof triggerData === 'object') {\n    console.log('‚úÖ Detected single object format');\n    \n    action = triggerData.action || 'processSurvey';\n    entityType = triggerData.entityType || 'dpe';\n    entityName = triggerData.entityName || triggerData.entityValue || 'Unknown';\n    \n    const inputData = [{\n      entityValue: triggerData.entityValue || triggerData.owner_full_name,\n      owner_full_name: triggerData.entityValue || triggerData.owner_full_name,\n      entityType: entityType,\n      entityName: entityName,\n      entityIndex: 0,\n      totalEntities: 1,\n      source: 'process-survey-single-entity'\n    }];\n    \n    return [{ \n      json: { \n        inputData: inputData,\n        processedCount: 0,\n        totalInputs: 1,\n        timestamp: new Date().toISOString(),\n        source: 'process-survey-single-entity',\n        entityType: entityType,\n        entityName: entityName,\n        action: action\n      } \n    }];\n  }\n  \n} catch (error) {\n  console.error('‚ùå ERROR in Process Survey Extract Entity:', error.message);\n  console.error('Stack trace:', error.stack);\n  \n  // Return default fallback\n  const fallbackData = [{\n    entityValue: 'Fallback Entity',\n    owner_full_name: 'Fallback Entity',\n    entityType: 'dpe',\n    entityName: 'Fallback Entity',\n    entityIndex: 0,\n    totalEntities: 1,\n    source: 'process-survey-error-fallback'\n  }];\n  \n  return [{ \n    json: { \n      inputData: fallbackData,\n      processedCount: 0,\n      totalInputs: 1,\n      timestamp: new Date().toISOString(),\n      source: 'process-survey-error-fallback',\n      error: error.message\n    } \n  }];\n}"
      },
      "id": "c37d9e3b-9fcf-4444-b8e3-bbc98129cd2c",
      "name": "Extract Entity",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1152, 16]
    },
    {
      "parameters": {
        "jsCode": "// Debug the input data and route accordingly\nconst inputJson = $input.first().json;\n\nconsole.log('=== CHECK INPUT DATA DEBUG ===');\nconsole.log('Full input JSON:', JSON.stringify(inputJson, null, 2));\nconsole.log('inputData exists:', !!inputJson.inputData);\nconsole.log('inputData type:', typeof inputJson.inputData);\nconsole.log('inputData isArray:', Array.isArray(inputJson.inputData));\nif (inputJson.inputData) {\n  console.log('inputData length:', inputJson.inputData.length);\n  console.log('inputData sample:', JSON.stringify(inputJson.inputData[0], null, 2));\n}\n\n// Check if inputData is valid\nconst isValid = inputJson.inputData && Array.isArray(inputJson.inputData) && inputJson.inputData.length > 0;\nconsole.log('Final validation result:', isValid);\n\nif (isValid) {\n  console.log('‚úÖ Routing to SUCCESS (Google Sheets)');\n  return [{\n    json: inputJson\n  }];\n} else {\n  console.log('‚ùå Routing to ERROR (No Data)');\n  return [null, {\n    json: {\n      error: 'No valid input data found',\n      inputReceived: inputJson,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "e209b164-8d39-469f-81f2-769c9ef5ce5a",
      "name": "Check Input Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1376, 16]
    },
    {
      "parameters": {
        "operation": "delete",
        "collection": "raw_survey_data"
      },
      "id": "eb78da65-2c18-46ca-acb0-aa35c785430b",
      "name": "Actually Clear Raw Survey Data",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1,
      "position": [1600, 16],
      "credentials": {
        "mongoDb": {
          "id": "Pl29NJOEfuRbqWf6",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1SyGG5NTsASyD2istBBztvAFGwWAsry74WkoISADOlZE",
          "mode": "list",
          "cachedResultName": "dbSashimi",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1SyGG5NTsASyD2istBBztvAFGwWAsry74WkoISADOlZE/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1036509206,
          "mode": "list",
          "cachedResultName": "Sheet3",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1SyGG5NTsASyD2istBBztvAFGwWAsry74WkoISADOlZE/edit#gid=1036509206"
        },
        "options": {}
      },
      "id": "c161dadf-00e9-4d70-a56c-7c3d80465f5b",
      "name": "Read Survey Google Sheet",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [1824, 16],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "GVsvgXnOvHSwccge",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Transform raw Google Sheets survey data for MongoDB storage\n// Filter to only include the specified columns\n// Process ALL input items, not just the first one\nconst allInputItems = $input.all();\n\nconsole.log('=== TRANSFORM RAW SURVEY DATA ===');\nconsole.log('Number of input items:', allInputItems.length);\n\n// Collect all survey data from all input items\nlet allSurveyData = [];\nallInputItems.forEach((item, index) => {\n  const rawSurveyData = item.json;\n  console.log(`Processing input item ${index}:`, typeof rawSurveyData, Array.isArray(rawSurveyData));\n  \n  // Handle different survey data formats\n  let surveyData = [];\n  if (Array.isArray(rawSurveyData)) {\n    surveyData = rawSurveyData;\n  } else if (rawSurveyData && rawSurveyData.values) {\n    surveyData = Array.isArray(rawSurveyData.values) ? rawSurveyData.values : [];\n  } else if (rawSurveyData && typeof rawSurveyData === 'object') {\n    surveyData = [rawSurveyData];\n  } else {\n    surveyData = [];\n  }\n  \n  allSurveyData = allSurveyData.concat(surveyData);\n});\n\nconsole.log('Total survey records collected:', allSurveyData.length);\n\n// Define the columns to keep\nconst columnsToKeep = [\n  'Owner (Case) (Case)',\n  'Case Number (Case) (Case)', \n  'Product Name (Case) (Case)',\n  'Technical Ability of Your Engineer',\n  'Overall Satisfaction',\n  'Overall Product Satisfaction',\n  'Additional Feedback or Commentary(Text)',\n  'Priority (Case) (Case)',\n  'Created On'\n];\n\n// Filter each survey record to only include specified columns\nconst filteredSurveys = allSurveyData.map((survey, index) => {\n  const filteredSurvey = {\n    _id: new Date().getTime() + Math.random() + index, // Unique ID with index\n    timestamp: new Date().toISOString(),\n    source: 'google-sheets-raw-import'\n  };\n  \n  // Add only the specified columns\n  columnsToKeep.forEach(column => {\n    if (survey.hasOwnProperty(column)) {\n      filteredSurvey[column] = survey[column];\n    }\n  });\n  \n  return filteredSurvey;\n});\n\nconsole.log('Filtered', filteredSurveys.length, 'records for raw storage');\nif (filteredSurveys.length > 0) {\n  console.log('Sample filtered record:', JSON.stringify(filteredSurveys[0], null, 2));\n  console.log('Last filtered record:', JSON.stringify(filteredSurveys[filteredSurveys.length - 1], null, 2));\n}\n\n// Return ALL filtered surveys for MongoDB insertion\nreturn filteredSurveys.map(survey => ({ json: survey }));"
      },
      "id": "3a639adb-b7b9-4236-a9e3-391730cd4786",
      "name": "Transform Raw Survey Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2048, 16]
    },
    {
      "parameters": {
        "operation": "insert",
        "collection": "raw_survey_data",
        "fields": "_id,timestamp,source,Owner (Case) (Case),Case Number (Case) (Case),Product Name (Case) (Case),Technical Ability of Your Engineer,Overall Satisfaction,Overall Product Satisfaction,Additional Feedback or Commentary(Text),Priority (Case) (Case),Created On",
        "options": {}
      },
      "id": "a187a0f9-cc4c-460b-9ed1-376115780fea",
      "name": "Save Raw Survey to MongoDB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1,
      "position": [2272, 16],
      "credentials": {
        "mongoDb": {
          "id": "Pl29NJOEfuRbqWf6",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process survey data and calculate satisfaction metrics for different entity types\n// FIXED FLOW: Get input data from the Check Input Data node and survey data from MongoDB save\nconst checkInputDataResult = $('Check Input Data').first().json;\nconst inputData = checkInputDataResult.inputData;\n\n// Get the survey data from the MongoDB save operation (Transform Raw Survey Data)\nconst mongoDbSaveData = $('Transform Raw Survey Data').all();\n\nconsole.log('=== PROCESS SATISFACTION DATA DEBUG (FIXED FLOW) ===');\nconsole.log('checkInputDataResult:', JSON.stringify(checkInputDataResult, null, 2).substring(0, 300));\nconsole.log('inputData length:', inputData ? inputData.length : 'undefined');\nconsole.log('mongoDbSaveData items:', mongoDbSaveData.length);\n\n// Collect all survey data from MongoDB save operation\nlet allSurveyData = [];\nmongoDbSaveData.forEach((item, index) => {\n  const rawSurveyData = item.json;\n  console.log(`Processing MongoDB save item ${index}:`, typeof rawSurveyData, Array.isArray(rawSurveyData));\n  \n  // The data from Transform Raw Survey Data should already be properly formatted\n  if (rawSurveyData && typeof rawSurveyData === 'object') {\n    allSurveyData.push(rawSurveyData);\n  }\n});\n\nconsole.log('Total survey data collected from MongoDB save:', allSurveyData.length);\n\nif (allSurveyData.length > 0) {\n  console.log('First survey sample:', JSON.stringify(allSurveyData[0], null, 2));\n  console.log('üîç ALL Survey column headers available:', Object.keys(allSurveyData[0] || {}));\n  \n  // Show satisfaction field examples specifically\n  const satisfactionSamples = allSurveyData.slice(0, 5).map(survey => {\n    return {\n      'Overall satisfaction': survey['Overall satisfaction'],\n      'Overall_satisfaction': survey['Overall_satisfaction'],\n      'Overall Satisfaction': survey['Overall Satisfaction'],\n      'Technical Ability of Your Engineer': survey['Technical Ability of Your Engineer'],\n      'Overall Product Satisfaction': survey['Overall Product Satisfaction']\n    };\n  });\n  console.log('üéØ Satisfaction field samples from first 5 surveys:');\n  console.log(JSON.stringify(satisfactionSamples, null, 2));\n  \n  // Show first few survey owner names for matching reference\n  const ownerSamples = allSurveyData.slice(0, 5).map(survey => {\n    return {\n      'Owner (Case)': survey['Owner (Case)'],\n      'Owner': survey['Owner'],\n      'Case Owner': survey['Case Owner'],\n      'Owner (Case) (Case)': survey['Owner (Case) (Case)'],\n      'Squad': survey['Squad'],\n      'Team': survey['Team'],\n      'Squad Name': survey['Squad Name'],\n      'Team Name': survey['Team Name']\n    };\n  });\n  console.log('üìã Owner samples from surveys (from MongoDB data):');\n  console.log(JSON.stringify(ownerSamples, null, 2));\n  \n  // Show actual satisfaction values to debug parsing\n  const satisfactionValues = allSurveyData.slice(0, 3).map(survey => {\n    const overallSat = survey['Overall satisfaction'] || survey['Overall_satisfaction'] || survey['Overall Satisfaction'] || survey['Technical Ability of Your Engineer'];\n    return {\n      rawValue: overallSat,\n      type: typeof overallSat,\n      parsed: parseInt(overallSat || 0),\n      isValid: !isNaN(parseInt(overallSat || 0)) && parseInt(overallSat || 0) > 0\n    };\n  });\n  console.log('üî¢ Satisfaction value parsing test (from MongoDB data):');\n  console.log(JSON.stringify(satisfactionValues, null, 2));\n} else {\n  console.log('‚ùå No survey data found from MongoDB save!');\n}\n\nconst results = [];\n\n// Process each entity from the input (can be DPE, Squad, or Team)\nfor (const entity of inputData) {\n  const entityType = entity.entityType || 'dpe';\n  const entityName = entity.entityName || entity.owner_full_name;\n  const entityValue = entity.entityValue || entity.owner_full_name;\n  \n  let relevantSurveys = [];\n  \n  if (allSurveyData.length === 0) {\n    console.log(`‚ö†Ô∏è No survey data available for entity: ${entityName}`);\n  } else {\n    console.log(`üîç Searching surveys for entity: ${entityName} (type: ${entityType})`);\n    console.log(`   entityValue: ${entityValue}`);\n    console.log(`   owner_full_name: ${entity.owner_full_name}`);\n    \n    // Add null/undefined checks before toLowerCase() calls\n    if (entityType && entityType.toLowerCase() === 'dpe') {\n      // For DPE: Find surveys for this specific person\n      const ownerName = entity.owner_full_name || entityValue;\n      console.log(`   Searching for DPE owner: \"${ownerName}\"`);      \n      relevantSurveys = allSurveyData.filter(survey => {\n        // Fixed field priority - check (Case) (Case) first\n        const surveyOwner = survey['Owner (Case) (Case)'] || survey['Owner (Case)'] || survey['Owner'] || survey['Case Owner'];\n        \n        // Improved matching with more flexible approach\n        let matches = false;\n        if (surveyOwner && ownerName) {\n          const surveyOwnerStr = surveyOwner.toString().toLowerCase().trim();\n          const ownerNameStr = ownerName.toString().toLowerCase().trim();\n          \n          // ENHANCED MATCHING: Multiple strategies for better DPE name accuracy\n          console.log(`   üîç DETAILED MATCHING: \"${surveyOwnerStr}\" vs \"${ownerNameStr}\"`);\n          \n          // Strategy 1: Exact match\n          if (surveyOwnerStr === ownerNameStr) {\n            matches = true;\n            console.log(`   ‚úÖ EXACT MATCH found`);\n          }\n          \n          // Strategy 2: Contains match (both directions)\n          if (!matches && (surveyOwnerStr.includes(ownerNameStr) || ownerNameStr.includes(surveyOwnerStr))) {\n            matches = true;\n            console.log(`   ‚úÖ CONTAINS MATCH found`);\n          }\n          \n          // Strategy 3: Enhanced name parts matching with better logic\n          if (!matches) {\n            const surveyOwnerParts = surveyOwnerStr.split(/\\\\s+/).filter(part => part.length > 1);\n            const ownerNameParts = ownerNameStr.split(/\\\\s+/).filter(part => part.length > 1);\n            \n            console.log(`   üìù Survey parts: [${surveyOwnerParts.join(', ')}]`);\n            console.log(`   üìù Owner parts: [${ownerNameParts.join(', ')}]`);\n            \n            // Check if we have at least 2 matching parts (first + last name typically)\n            let matchingParts = 0;\n            surveyOwnerParts.forEach(surveyPart => {\n              ownerNameParts.forEach(ownerPart => {\n                if (surveyPart.length >= 2 && ownerPart.length >= 2) {\n                  // Exact part match\n                  if (surveyPart === ownerPart) {\n                    matchingParts++;\n                    console.log(`   ‚úÖ EXACT PART MATCH: \"${surveyPart}\" = \"${ownerPart}\"`);\n                  }\n                  // Partial part match (one contains the other)\n                  else if (surveyPart.includes(ownerPart) || ownerPart.includes(surveyPart)) {\n                    matchingParts += 0.5; // Half point for partial match\n                    console.log(`   ‚úÖ PARTIAL PART MATCH: \"${surveyPart}\" ~ \"${ownerPart}\"`);\n                  }\n                }\n              });\n            });\n            \n            // Need at least 1.5 points (e.g., 2 exact matches, or 1 exact + 1 partial, or 3 partials)\n            if (matchingParts >= 1.5) {\n              matches = true;\n              console.log(`   ‚úÖ PARTS MATCH found (score: ${matchingParts})`);\n            } else {\n              console.log(`   ‚ùå PARTS MATCH failed (score: ${matchingParts}, need >= 1.5)`);\n            }\n          }\n          \n          // Strategy 4: Handle initials in entity names (since survey Owner always has full names)\n          if (!matches) {\n            // Only check if entity name might have initials (survey names are always full)\n            const ownerNameParts = ownerNameStr.split(/\\\\s+/).filter(part => part.length > 0);\n            const hasInitials = ownerNameStr.includes('.') || ownerNameParts.some(part => part.length === 1);\n            \n            if (hasInitials) {\n              console.log(`   üî§ ENTITY INITIALS detected, trying initial matching`);\n              \n              const surveyOwnerParts = surveyOwnerStr.split(/\\\\s+/).filter(part => part.length > 0);\n              \n              // Entity has initials, survey has full names - match initials to first letters\n              const entityInitials = ownerNameParts.filter(part => part.length <= 2).map(p => p.replace('.', ''));\n              const entityFullNames = ownerNameParts.filter(part => part.length > 2);\n              const surveyFullNames = surveyOwnerParts; // Survey names are always full\n              \n              console.log(`   Entity initials: [${entityInitials.join(', ')}], entity full: [${entityFullNames.join(', ')}]`);\n              console.log(`   Survey full names: [${surveyFullNames.join(', ')}]`);\n              \n              let initialMatches = 0;\n              \n              // Match entity initials with first letters of survey full names\n              entityInitials.forEach(initial => {\n                surveyFullNames.forEach(surveyFull => {\n                  if (surveyFull.startsWith(initial.toLowerCase())) {\n                    initialMatches++;\n                    console.log(`   ‚úÖ INITIAL MATCH: entity \"${initial}\" matches start of survey \"${surveyFull}\"`);\n                  }\n                });\n              });\n              \n              // Match entity full names with survey full names\n              entityFullNames.forEach(entityFull => {\n                surveyFullNames.forEach(surveyFull => {\n                  if (entityFull === surveyFull || entityFull.includes(surveyFull) || surveyFull.includes(entityFull)) {\n                    initialMatches++;\n                    console.log(`   ‚úÖ FULL NAME MATCH: entity \"${entityFull}\" ~ survey \"${surveyFull}\"`);\n                  }\n                });\n              });\n              \n              if (initialMatches >= 1) {\n                matches = true;\n                console.log(`   ‚úÖ INITIALS MATCH found (${initialMatches} matches)`);\n              } else {\n                console.log(`   ‚ùå INITIALS MATCH failed (${initialMatches} matches, need >= 1)`);\n              }\n            }\n          }\n        }\n        \n        if (surveyOwner) {\n          console.log(`   Survey owner \"${surveyOwner}\" vs \"${ownerName}\" = ${matches}`);\n        }\n        \n        return matches;\n      });\n    } else if (entityType && (entityType.toLowerCase() === 'squad' || entityType.toLowerCase() === 'team')) {\n      // For Squad/Team: Find surveys for this individual member only (no squad name matching)\n      const ownerName = entity.owner_full_name || entityValue;\n      console.log(`   Searching for ${entityType} member: \"${ownerName}\"`);      \n      relevantSurveys = allSurveyData.filter(survey => {\n        // Fixed field priority - check (Case) (Case) first\n        const surveyOwner = survey['Owner (Case) (Case)'] || survey['Owner (Case)'] || survey['Owner'] || survey['Case Owner'];\n        \n        // Improved matching with more flexible approach\n        let memberMatch = false;\n        if (surveyOwner && ownerName) {\n          const surveyOwnerStr = surveyOwner.toString().toLowerCase().trim();\n          const ownerNameStr = ownerName.toString().toLowerCase().trim();\n          \n          // ENHANCED MATCHING: Multiple strategies for better Squad/Team member name accuracy\n          console.log(`   üîç DETAILED MEMBER MATCHING: \"${surveyOwnerStr}\" vs \"${ownerNameStr}\"`);\n          \n          // Strategy 1: Exact match\n          if (surveyOwnerStr === ownerNameStr) {\n            memberMatch = true;\n            console.log(`   ‚úÖ EXACT MATCH found`);\n          }\n          \n          // Strategy 2: Contains match (both directions)\n          if (!memberMatch && (surveyOwnerStr.includes(ownerNameStr) || ownerNameStr.includes(surveyOwnerStr))) {\n            memberMatch = true;\n            console.log(`   ‚úÖ CONTAINS MATCH found`);\n          }\n          \n          // Strategy 3: Enhanced name parts matching with better logic\n          if (!memberMatch) {\n            const surveyOwnerParts = surveyOwnerStr.split(/\\\\s+/).filter(part => part.length > 1);\n            const ownerNameParts = ownerNameStr.split(/\\\\s+/).filter(part => part.length > 1);\n            \n            console.log(`   üìù Survey parts: [${surveyOwnerParts.join(', ')}]`);\n            console.log(`   üìù Owner parts: [${ownerNameParts.join(', ')}]`);\n            \n            // Check if we have at least 2 matching parts (first + last name typically)\n            let matchingParts = 0;\n            surveyOwnerParts.forEach(surveyPart => {\n              ownerNameParts.forEach(ownerPart => {\n                if (surveyPart.length >= 2 && ownerPart.length >= 2) {\n                  // Exact part match\n                  if (surveyPart === ownerPart) {\n                    matchingParts++;\n                    console.log(`   ‚úÖ EXACT PART MATCH: \"${surveyPart}\" = \"${ownerPart}\"`);\n                  }\n                  // Partial part match (one contains the other)\n                  else if (surveyPart.includes(ownerPart) || ownerPart.includes(surveyPart)) {\n                    matchingParts += 0.5; // Half point for partial match\n                    console.log(`   ‚úÖ PARTIAL PART MATCH: \"${surveyPart}\" ~ \"${ownerPart}\"`);\n                  }\n                }\n              });\n            });\n            \n            // Need at least 1.5 points (e.g., 2 exact matches, or 1 exact + 1 partial, or 3 partials)\n            if (matchingParts >= 1.5) {\n              memberMatch = true;\n              console.log(`   ‚úÖ PARTS MATCH found (score: ${matchingParts})`);\n            } else {\n              console.log(`   ‚ùå PARTS MATCH failed (score: ${matchingParts}, need >= 1.5)`);\n            }\n          }\n          \n          // Strategy 4: Handle initials in member names (since survey Owner always has full names)\n          if (!memberMatch) {\n            // Only check if member name might have initials (survey names are always full)\n            const ownerNameParts = ownerNameStr.split(/\\\\s+/).filter(part => part.length > 0);\n            const hasInitials = ownerNameStr.includes('.') || ownerNameParts.some(part => part.length === 1);\n            \n            if (hasInitials) {\n              console.log(`   üî§ MEMBER INITIALS detected, trying initial matching`);\n              \n              const surveyOwnerParts = surveyOwnerStr.split(/\\\\s+/).filter(part => part.length > 0);\n              \n              // Member has initials, survey has full names - match initials to first letters\n              const memberInitials = ownerNameParts.filter(part => part.length <= 2).map(p => p.replace('.', ''));\n              const memberFullNames = ownerNameParts.filter(part => part.length > 2);\n              const surveyFullNames = surveyOwnerParts; // Survey names are always full\n              \n              console.log(`   Member initials: [${memberInitials.join(', ')}], member full: [${memberFullNames.join(', ')}]`);\n              console.log(`   Survey full names: [${surveyFullNames.join(', ')}]`);\n              \n              let initialMatches = 0;\n              \n              // Match member initials with first letters of survey full names\n              memberInitials.forEach(initial => {\n                surveyFullNames.forEach(surveyFull => {\n                  if (surveyFull.startsWith(initial.toLowerCase())) {\n                    initialMatches++;\n                    console.log(`   ‚úÖ INITIAL MATCH: member \"${initial}\" matches start of survey \"${surveyFull}\"`);\n                  }\n                });\n              });\n              \n              // Match member full names with survey full names\n              memberFullNames.forEach(memberFull => {\n                surveyFullNames.forEach(surveyFull => {\n                  if (memberFull === surveyFull || memberFull.includes(surveyFull) || surveyFull.includes(memberFull)) {\n                    initialMatches++;\n                    console.log(`   ‚úÖ FULL NAME MATCH: member \"${memberFull}\" ~ survey \"${surveyFull}\"`);\n                  }\n                });\n              });\n              \n              if (initialMatches >= 1) {\n                memberMatch = true;\n                console.log(`   ‚úÖ INITIALS MATCH found (${initialMatches} matches)`);\n              } else {\n                console.log(`   ‚ùå INITIALS MATCH failed (${initialMatches} matches, need >= 1)`);\n              }\n            }\n          }\n        }\n        \n        if (surveyOwner) {\n          console.log(`   Survey owner \"${surveyOwner}\" vs member \"${ownerName}\" = ${memberMatch}`);\n        }\n        \n        return memberMatch;\n      });\n    }\n  }\n  \n  console.log(`üìä Found ${relevantSurveys.length} relevant surveys for ${entityName}`);\n  \n  // Enhanced debugging for survey matching\n  if (relevantSurveys.length === 0) {\n    console.log(`‚ùå NO SURVEYS FOUND for ${entityName}. Debugging:`);\n    console.log(`   - Entity name: \"${entityName}\"`);\n    console.log(`   - Entity value: \"${entityValue}\"`);\n    console.log(`   - owner_full_name: \"${entity.owner_full_name}\"`);\n    console.log(`   - Total surveys available: ${allSurveyData.length}`);\n    \n    // Show sample of available survey owners for comparison\n    const availableOwners = allSurveyData.slice(0, 5).map(s => {\n      return s['Owner (Case) (Case)'] || s['Owner (Case)'] || s['Owner'] || s['Case Owner'] || 'NO_OWNER';\n    });\n    console.log(`   - Sample survey owners: [${availableOwners.join(', ')}]`);\n  }\n  \n  if (relevantSurveys.length > 0) {\n    console.log('Survey details:');\n    relevantSurveys.forEach((survey, idx) => {\n      const satisfaction = survey['Overall satisfaction'] || survey['Overall_satisfaction'] || survey['Technical Ability of Your Engineer'];\n      const caseNum = survey['Case Number'] || survey['Case_Number'] || survey['Case ID'] || survey['Case Number (Case) (Case)'];\n      console.log(`   ${idx + 1}: Case=${caseNum}, Satisfaction=${satisfaction}`);\n    });\n  }\n  \n  let csatCount = 0;\n  let neutralCount = 0;\n  let dsatCount = 0;\n  const surveyDetails = [];\n  \n  console.log(`üîÑ Processing ${relevantSurveys.length} surveys for satisfaction calculation...`);\n  \n  // Process each relevant survey response\n  for (const survey of relevantSurveys) {\n    console.log(`Processing survey:`, JSON.stringify(survey, null, 2).substring(0, 300));\n    \n    // Try multiple satisfaction field names\n    const overallSatisfaction = parseInt(\n      survey['Overall satisfaction'] || \n      survey['Overall_satisfaction'] || \n      survey['Overall Satisfaction'] ||\n      survey['Technical Ability of Your Engineer'] ||\n      survey['Overall Product Satisfaction'] || \n      0\n    );\n    const caseNumber = survey['Case Number'] || survey['Case_Number'] || survey['Case ID'] || survey['Case Number (Case) (Case)'] || '';\n    const feedback = survey['Additional Feedback or Commentary (Text)'] || survey['Additional Feedback or Commentary(Text)'] || survey['Feedback'] || survey['Commentary'] || '';\n    const surveyOwner = survey['Owner (Case) (Case)'] || survey['Owner (Case)'] || survey['Owner'] || survey['Case Owner'] || '';\n    \n    console.log(`   Raw satisfaction value: \"${survey['Overall satisfaction'] || survey['Overall_satisfaction'] || survey['Technical Ability of Your Engineer']}\"`); \n    console.log(`   Parsed satisfaction: ${overallSatisfaction}`);\n    console.log(`   Case number: \"${caseNumber}\"`);\n    console.log(`   Survey owner: \"${surveyOwner}\"`);\n    \n    // Categorize satisfaction with detailed logging\n    let category = 'neutral';\n    if (overallSatisfaction >= 4) {\n      csatCount++;\n      category = 'csat';\n      console.log(`   ‚úÖ CSAT (${overallSatisfaction} >= 4) - csatCount now: ${csatCount}`);\n    } else if (overallSatisfaction === 3) {\n      neutralCount++;\n      category = 'neutral';\n      console.log(`   üòê NEUTRAL (${overallSatisfaction} = 3) - neutralCount now: ${neutralCount}`);\n    } else if (overallSatisfaction <= 2 && overallSatisfaction > 0) {\n      dsatCount++;\n      category = 'dsat';\n      console.log(`   ‚ùå DSAT (${overallSatisfaction} <= 2) - dsatCount now: ${dsatCount}`);\n    } else {\n      console.log(`   ‚ö†Ô∏è INVALID/ZERO satisfaction (${overallSatisfaction}) - not counted`);\n    }\n    \n    // Store survey details\n    surveyDetails.push({\n      caseNumber: caseNumber,\n      overallSatisfaction: overallSatisfaction,\n      category: category,\n      feedback: feedback,\n      surveyDate: survey['Date'] || survey['Survey Date'] || new Date().toISOString(),\n      customerName: survey['Customer Name'] || survey['Customer'] || '',\n      productArea: survey['Product Area'] || survey['Product'] || '',\n      ownerName: surveyOwner\n    });\n  }\n  \n  console.log(`üìä Final counts: CSAT=${csatCount}, Neutral=${neutralCount}, DSAT=${dsatCount}`);\n  \n  // Calculate percentages\n  const totalSurveys = csatCount + neutralCount + dsatCount;\n  const csatPercentage = totalSurveys > 0 ? Math.round((csatCount / totalSurveys) * 100) : 0;\n  const neutralPercentage = totalSurveys > 0 ? Math.round((neutralCount / totalSurveys) * 100) : 0;\n  const dsatPercentage = totalSurveys > 0 ? Math.round((dsatCount / totalSurveys) * 100) : 0;\n  \n  // Create satisfaction object with validation\n  const satisfactionData = {\n    csat: csatCount || 0,\n    neutral: neutralCount || 0,\n    dsat: dsatCount || 0,\n    total: totalSurveys || 0,\n    csatPercentage: csatPercentage || 0,\n    neutralPercentage: neutralPercentage || 0,\n    dsatPercentage: dsatPercentage || 0\n  };\n  \n  // Log satisfaction data for this entity\n  console.log(`Entity ${entityName} satisfaction:`, JSON.stringify(satisfactionData, null, 2));\n  \n  // Prepare result object with dynamic entity information\n  const resultObject = {\n    entityId: entityValue,\n    entityType: entityType,\n    entityName: entityName,\n    owner_full_name: entity.owner_full_name || entityValue,\n    entityIndex: entity.entityIndex || 0,\n    totalEntities: entity.totalEntities || 1,\n    satisfaction: satisfactionData,\n    surveyDetails: surveyDetails,\n    timestamp: new Date().toISOString(),\n    source: 'satisfaction-survey-workflow'\n  };\n  \n  // Validate the result object\n  console.log(`Result object for ${entityName}:`, {\n    hasEntityId: !!resultObject.entityId,\n    hasEntityType: !!resultObject.entityType,\n    hasEntityName: !!resultObject.entityName,\n    hasSatisfaction: !!resultObject.satisfaction,\n    satisfactionKeys: Object.keys(resultObject.satisfaction || {}),\n    satisfactionValues: Object.values(resultObject.satisfaction || {})\n  });\n  \n  results.push(resultObject);\n}\n\nconsole.log(`‚úÖ Processed ${results.length} entities with satisfaction data`);\n\n// Final validation of all results\nresults.forEach((result, index) => {\n  console.log(`Final result ${index}:`, {\n    entityName: result.entityName,\n    hasSatisfaction: !!result.satisfaction,\n    satisfactionStructure: result.satisfaction,\n    surveyCount: result.surveyDetails ? result.surveyDetails.length : 0\n  });\n});\n\n// Ensure each result has proper structure\nconst validatedResults = results.map((result, index) => {\n  if (!result.satisfaction) {\n    console.warn(`‚ö†Ô∏è Result ${index} missing satisfaction data, adding defaults`);\n    result.satisfaction = {\n      csat: 0,\n      neutral: 0,\n      dsat: 0,\n      total: 0,\n      csatPercentage: 0,\n      neutralPercentage: 0,\n      dsatPercentage: 0\n    };\n  }\n  return { json: result };\n});\n\nconsole.log('üîÑ Returning validated results:', validatedResults.length);\nreturn validatedResults;"
      },
      "id": "d9e97795-becd-40b0-a7f6-26e6b6ca135f",
      "name": "Process Satisfaction Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2496, 16]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "l2m16n20-2t16-8s4r-pt6q-9s2t3t4t5t6t",
              "name": "error",
              "value": "No input data provided",
              "type": "string"
            },
            {
              "id": "m3n27o31-3u27-9t5s-qu7r-0t3u4u5u6u7u",
              "name": "timestamp",
              "value": "={{ $now }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "37a5b5f4-98a5-4318-b457-111752826108",
      "name": "Error - No Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [928, 240]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "eaaac453-6c63-4b8f-b4bf-891127fc1d57",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1152, 240]
    },
    {
      "parameters": {
        "jsCode": "// Save satisfaction data to performance_data database in metrics field\n// This enables Customer Survey Distribution to display CSAT/Neutral/DSAT by entity\nconst allSatisfactionData = $input.all();\n\nconsole.log('=== SAVE SATISFACTION TO PERFORMANCE_DATA ===');\nconsole.log('Received satisfaction items:', allSatisfactionData.length);\n\nconst performanceUpdates = [];\nconst currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format\nconst currentTimestamp = new Date().toISOString();\n\nfor (const item of allSatisfactionData) {\n  const satisfactionData = item.json;\n  \n  console.log(`Processing satisfaction data for: ${satisfactionData.entityName}`);\n  console.log(`Entity type: ${satisfactionData.entityType}`);\n  console.log(`Satisfaction:`, satisfactionData.satisfaction);\n  \n  // Create unique identifier with timestamp to prevent duplicates\n  const uniqueId = `satisfaction-${satisfactionData.entityType}-${satisfactionData.entityName}-${Date.now()}`.replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();\n  \n  // Prepare performance data record matching the expected structure\n  const performanceUpdate = {\n    entity_id: satisfactionData.entityId || uniqueId,\n    entity_name: satisfactionData.entityName,\n    entity_type: satisfactionData.entityType,\n    date: currentDate,\n    \n    // üöÄ UPDATED METRICS: Clean structure without SCT/cases/satisfaction placeholders (v2.1)\n    metrics: {\n      // Detailed customer satisfaction breakdown\n      customerSatisfaction: {\n        csat: satisfactionData.satisfaction.csat || 0,\n        neutral: satisfactionData.satisfaction.neutral || 0,\n        dsat: satisfactionData.satisfaction.dsat || 0,\n        total: satisfactionData.satisfaction.total || 0,\n        csatPercentage: satisfactionData.satisfaction.csatPercentage || 0,\n        neutralPercentage: satisfactionData.satisfaction.neutralPercentage || 0,\n        dsatPercentage: satisfactionData.satisfaction.dsatPercentage || 0,\n        lastUpdated: currentTimestamp,\n        source: 'satisfaction-survey-workflow'\n      },\n      \n      // Include survey details for drill-down capability\n      surveyDetails: satisfactionData.surveyDetails || []\n    },\n    \n    created_at: new Date(),\n    source: 'satisfaction-workflow'\n  };\n  \n  console.log(`Performance update for ${satisfactionData.entityName}:`, {\n    uniqueId: uniqueId,\n    entityName: performanceUpdate.entity_name,\n    hasMetrics: !!performanceUpdate.metrics,\n    hasSatisfaction: !!performanceUpdate.metrics.customerSatisfaction,\n    csatPercentage: performanceUpdate.metrics.customerSatisfaction.csatPercentage,\n    totalSurveys: performanceUpdate.metrics.customerSatisfaction.total,\n    surveyCount: performanceUpdate.metrics.surveyDetails.length\n  });\n  \n  performanceUpdates.push(performanceUpdate);\n}\n\nconsole.log(`Prepared ${performanceUpdates.length} performance updates with unique IDs`);\nconsole.log('Sample performance update:', JSON.stringify(performanceUpdates[0] || {}, null, 2));\n\n// Debug: Log the final structure that will be sent to MongoDB\nperformanceUpdates.forEach((update, index) => {\n  console.log(`UPDATE ${index}:`, {\n    hasEntityName: !!update.entity_name,\n    hasEntityType: !!update.entity_type,\n    hasMetrics: !!update.metrics,\n    hasCustomerSatisfaction: !!update.metrics?.customerSatisfaction,\n    keys: Object.keys(update)\n  });\n});\n\n// Return the performance updates for MongoDB insertMany operation\n// For insertMany, each item should be a complete document\nreturn performanceUpdates.map(update => ({ json: update }));"
      },
      "id": "c7e4db84-deaf-4142-a6ef-ff60ad0cbfa0",
      "name": "Prepare Performance Data Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2720, 16]
    },
    {
      "parameters": {},
      "id": "17e252d0-aed1-4543-a467-7ac58949e834",
      "name": "Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2944, 16]
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [848, 0],
      "id": "39d6ad55-9b4e-452c-bb20-5eea9d2f4857",
      "name": "When Executed by Another Workflow"
    }
  ],
  "pinData": {},
  "connections": {
    "Extract Entity": {
      "main": [
        [
          {
            "node": "Check Input Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Input Data": {
      "main": [
        [
          {
            "node": "Actually Clear Raw Survey Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Actually Clear Raw Survey Data": {
      "main": [
        [
          {
            "node": "Read Survey Google Sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Survey Google Sheet": {
      "main": [
        [
          {
            "node": "Transform Raw Survey Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform Raw Survey Data": {
      "main": [
        [
          {
            "node": "Save Raw Survey to MongoDB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Raw Survey to MongoDB": {
      "main": [
        [
          {
            "node": "Process Satisfaction Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Satisfaction Data": {
      "main": [
        [
          {
            "node": "Prepare Performance Data Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Performance Data Updates": {
      "main": [
        [
          {
            "node": "Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error - No Data": {
      "main": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Extract Entity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "99585f6a-849e-4285-8e65-5f49b74a9701",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "4ae47e0d2927c2ad6ce432ba64a316fc4b36f12b6aeb96b5fb893ad9ad8e6961"
  },
  "id": "dP6H6aWkrIG79yuw",
  "tags": []
}
