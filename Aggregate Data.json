{
  "name": "Save KPI",
  "nodes": [
    {
      "parameters": {},
      "id": "1ff75981-f10c-459e-b864-5b00a2499029",
      "name": "Aggregate Data Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [-352, -96]
    },
    {
      "parameters": {
        "jsCode": "// Combine KPI data from Calculate Metrics and Process Survey workflows\nconst allInputData = $input.all();\n\nconsole.log('=== SAVE KPI WORKFLOW - DATA MERGING ===');\nconsole.log('Received items for KPI merge:', allInputData.length);\n\n// Separate records by type and group by entity\nconst casePerformanceRecords = new Map();\nconst satisfactionRecords = new Map();\n\nallInputData.forEach((item, index) => {\n  const kpiData = item.json;\n  const entityName = kpiData.entity_name || kpiData.entityName;\n  \n  console.log(`ðŸ” Processing record ${index + 1}:`, {\n    entityName,\n    entityType: kpiData.entity_type,\n    entityId: kpiData.entity_id,\n    hasCustomerSatisfaction: !!kpiData.metrics?.customerSatisfaction,\n    hasSCT: kpiData.metrics?.sct !== undefined,\n    hasSampleCases: !!kpiData.sample_cases,\n    source: kpiData.source\n  });\n  \n  // Determine record type\n  if (kpiData.metrics?.customerSatisfaction) {\n    // This is a satisfaction record from Process Survey\n    console.log(`ðŸ“Š Satisfaction record ${index + 1}: ${entityName}`);\n    satisfactionRecords.set(entityName, kpiData);\n  } else if (kpiData.metrics?.sct !== undefined || kpiData.sample_cases) {\n    // This is a case performance record from Calculate Metrics\n    console.log(`ðŸ“ˆ Case performance record ${index + 1}: ${entityName}`);\n    casePerformanceRecords.set(entityName, kpiData);\n  } else {\n    console.log(`âš ï¸ Unknown record type ${index + 1}: ${entityName}`);\n  }\n});\n\nconsole.log('ðŸ“‹ Data grouping summary:', {\n  casePerformanceEntities: Array.from(casePerformanceRecords.keys()),\n  satisfactionEntities: Array.from(satisfactionRecords.keys()),\n  totalCaseRecords: casePerformanceRecords.size,\n  totalSatisfactionRecords: satisfactionRecords.size\n});\n\n// Debug the entity matching problem\nif (casePerformanceRecords.size === 0) {\n  console.log('ðŸ”¥ CRITICAL: No case performance records found!');\n  console.log('ðŸ” All input records:', allInputData.map(item => ({\n    entity_name: item.json.entity_name,\n    entity_type: item.json.entity_type,\n    hasMetrics: !!item.json.metrics,\n    metricsKeys: item.json.metrics ? Object.keys(item.json.metrics) : [],\n    hasSampleCases: !!item.json.sample_cases,\n    source: item.json.source\n  })));\n}\n\nif (satisfactionRecords.size > 0 && casePerformanceRecords.size === 0) {\n  console.log('âš ï¸ MISMATCH: We have satisfaction records but NO case performance records');\n  console.log('This suggests the Calculate Metrics workflow is not running or not producing output');\n}\n\n// Merge data by entity - use case performance as base, add satisfaction data\nconst mergedRecords = [];\n\n// Process each case performance record as the base\ncasePerformanceRecords.forEach((caseRecord, entityName) => {\n  const satisfactionRecord = satisfactionRecords.get(entityName);\n  \n  console.log(`ðŸ”„ Merging data for: ${entityName}`, {\n    hasCaseData: !!caseRecord,\n    hasSatisfactionData: !!satisfactionRecord\n  });\n  \n  // Create merged record with case performance as base\n  const mergedRecord = {\n    entity_id: caseRecord.entity_name || caseRecord.entity_id, // Use consistent entity identifier\n    entity_name: caseRecord.entity_name,\n    entity_type: caseRecord.entity_type,\n    date: caseRecord.date,\n    \n    // Merge metrics: case performance + satisfaction data\n    metrics: {\n      // Case performance metrics\n      sct: caseRecord.metrics?.sct || 0,\n      closedCases: caseRecord.metrics?.closedCases || 0,\n      \n      // Add satisfaction data if available\n      ...(satisfactionRecord?.metrics?.customerSatisfaction && {\n        customerSatisfaction: satisfactionRecord.metrics.customerSatisfaction\n      })\n    },\n    \n    // Case performance specific fields\n    cases_count: caseRecord.cases_count || 0,\n    sample_cases: caseRecord.sample_cases || [],\n    \n    // Survey details at root level (not in metrics)\n    ...(satisfactionRecord?.metrics?.surveyDetails && {\n      surveyDetails: satisfactionRecord.metrics.surveyDetails\n    }),\n    \n    metadata: caseRecord.metadata || {},\n    \n    // Timestamps - use most recent or case performance timestamps\n    created_at: caseRecord.created_at,\n    updated_at: caseRecord.updated_at || new Date(),\n    \n    // Source tracking\n    source: satisfactionRecord?.source ? \n      `${caseRecord.source || 'case-workflow'} + ${satisfactionRecord.source}` : \n      (caseRecord.source || 'case-workflow')\n  };\n  \n  mergedRecords.push(mergedRecord);\n  \n  console.log(`âœ… Merged record for ${entityName}:`, {\n    hasScMetrics: !!(mergedRecord.metrics.sct || mergedRecord.metrics.closedCases),\n    hasSatisfactionMetrics: !!mergedRecord.metrics.customerSatisfaction,\n    hasSurveyDetails: !!mergedRecord.surveyDetails,\n    casesCount: mergedRecord.cases_count,\n    sampleCasesCount: mergedRecord.sample_cases?.length || 0\n  });\n});\n\n// Handle satisfaction records that don't have corresponding case performance records\nsatisfactionRecords.forEach((satisfactionRecord, entityName) => {\n  if (!casePerformanceRecords.has(entityName)) {\n    console.log(`âš ï¸ SKIPPING Satisfaction-only record for: ${entityName} (no case performance data found)`);\n    console.log(`âŒ Available case performance entities:`, Array.from(casePerformanceRecords.keys()));\n    console.log(`âŒ This satisfaction entity: ${entityName} not found in case performance records`);\n    \n    // DO NOT CREATE satisfaction-only records - they cause excess data\n    // Instead, log the issue for debugging\n    console.log(`ðŸš« Not saving satisfaction-only record for ${entityName} to prevent excess data`);\n  }\n});\n\nconsole.log('ðŸŽ¯ Final merged records summary:', {\n  totalMergedRecords: mergedRecords.length,\n  entitiesWithBothData: casePerformanceRecords.size,\n  entitiesWithSatisfactionOnly: satisfactionRecords.size - casePerformanceRecords.size\n});\n\nif (mergedRecords.length > 0) {\n  console.log('ðŸ“‹ Sample merged record structure:', Object.keys(mergedRecords[0]));\n  console.log('ðŸ“Š Sample metrics keys:', Object.keys(mergedRecords[0].metrics));\n}\n\n// Return merged records for MongoDB insertion\nreturn mergedRecords.map(record => ({ json: record }));"
      },
      "id": "69fc2f6c-f3cb-4c22-ac0e-aedcc401cbb6",
      "name": "Process Aggregate Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-128, -96]
    },
    {
      "parameters": {
        "operation": "insert",
        "collection": "performance_data",
        "fields": "entity_id, entity_name, entity_type, date, metrics, cases_count, sample_cases, surveyDetails, metadata, created_at, updated_at, source",
        "options": {}
      },
      "id": "73e8b6f5-f26c-4e0d-b19d-2b264cbd99b0",
      "name": "Save Aggregate Data",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1,
      "position": [96, -96],
      "credentials": {
        "mongoDb": {
          "id": "Pl29NJOEfuRbqWf6",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "id": "93598bf2-3453-411b-a609-308046f2b59d",
      "name": "Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [320, -96]
    }
  ],
  "pinData": {},
  "connections": {
    "Aggregate Data Trigger": {
      "main": [
        [
          {
            "node": "Process Aggregate Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Aggregate Data": {
      "main": [
        [
          {
            "node": "Save Aggregate Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Aggregate Data": {
      "main": [
        [
          {
            "node": "Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "5cb0d819-7d46-45db-90d0-dd08b7b284af",
  "meta": {
    "instanceId": "4ae47e0d2927c2ad6ce432ba64a316fc4b36f12b6aeb96b5fb893ad9ad8e6961"
  },
  "id": "QkTL13ss9wmvB2Fm",
  "tags": []
}
