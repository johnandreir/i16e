{
  "name": "Save KPI",
  "nodes": [
    {
      "parameters": {},
      "id": "29ab0f22-0384-4c69-ae6a-ce5a17875f74",
      "name": "Aggregate Data Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        256,
        -96
      ]
    },
    {
      "parameters": {
        "jsCode": "// Combine KPI data from Calculate Metrics and Process Survey workflows\nconst allInputData = $input.all();\n\nconsole.log('=== SAVE KPI WORKFLOW - DATA MERGING ===');\nconsole.log('Received items for KPI merge:', allInputData.length);\n\n// Separate records by type and group by entity\nconst casePerformanceRecords = new Map();\nconst satisfactionRecords = new Map();\n// Also track satisfaction records by entity_id for better matching\nconst satisfactionRecordsById = new Map();\n\nallInputData.forEach((item, index) => {\n  const kpiData = item.json;\n  const entityName = kpiData.entity_name || kpiData.entityName;\n  const entityId = kpiData.entity_id;\n  \n  console.log(`ðŸ” Processing record ${index + 1}:`, {\n    entityName,\n    entityType: kpiData.entity_type,\n    entityId,\n    hasCustomerSatisfaction: !!kpiData.metrics?.customerSatisfaction,\n    hasSCT: kpiData.metrics?.sct !== undefined,\n    hasSampleCases: !!kpiData.sample_cases,\n    source: kpiData.source\n  });\n  \n  // Determine record type\n  if (kpiData.metrics?.customerSatisfaction) {\n    // This is a satisfaction record from Process Survey\n    console.log(`ðŸ“Š Satisfaction record ${index + 1}: ${entityName} (entity_id: ${entityId})`);\n    satisfactionRecords.set(entityName, kpiData);\n    // Also index by entity_id for better matching\n    if (entityId) {\n      console.log(`ðŸ“Š Also indexing satisfaction record by entity_id: ${entityId}`);\n      satisfactionRecordsById.set(entityId, kpiData);\n    }\n  } else if (kpiData.metrics?.sct !== undefined || kpiData.sample_cases) {\n    // This is a case performance record from Calculate Metrics\n    console.log(`ðŸ“ˆ Case performance record ${index + 1}: ${entityName}`);\n    casePerformanceRecords.set(entityName, kpiData);\n  } else {\n    console.log(`âš ï¸ Unknown record type ${index + 1}: ${entityName}`);\n  }\n});\n\nconsole.log('ðŸ“‹ Data grouping summary:', {\n  casePerformanceEntities: Array.from(casePerformanceRecords.keys()),\n  satisfactionEntities: Array.from(satisfactionRecords.keys()),\n  satisfactionEntitiesById: Array.from(satisfactionRecordsById.keys()),\n  totalCaseRecords: casePerformanceRecords.size,\n  totalSatisfactionRecords: satisfactionRecords.size,\n  totalSatisfactionRecordsById: satisfactionRecordsById.size\n});\n\n// Debug the entity matching problem\nif (casePerformanceRecords.size === 0) {\n  console.log('ðŸ”¥ CRITICAL: No case performance records found!');\n  console.log('ðŸ” All input records:', allInputData.map(item => ({\n    entity_name: item.json.entity_name,\n    entity_type: item.json.entity_type,\n    entity_id: item.json.entity_id,\n    hasMetrics: !!item.json.metrics,\n    metricsKeys: item.json.metrics ? Object.keys(item.json.metrics) : [],\n    hasSampleCases: !!item.json.sample_cases,\n    source: item.json.source\n  })));\n}\n\nif (satisfactionRecords.size > 0 && casePerformanceRecords.size === 0) {\n  console.log('âš ï¸ MISMATCH: We have satisfaction records but NO case performance records');\n  console.log('This suggests the Calculate Metrics workflow is not running or not producing output');\n}\n\n// Merge data by entity - use case performance as base, add satisfaction data\nconst mergedRecords = [];\n\n// Process each case performance record as the base\ncasePerformanceRecords.forEach((caseRecord, entityName) => {\n  // First try to find a match by entity_id which is more reliable\n  let satisfactionRecord = null;\n  const caseEntityId = caseRecord.entity_id || entityName;\n  \n  // PRIMARY MATCHING: Try to match by entity_id first (more reliable since this is the DPE name in both datasets)\n  if (caseEntityId) {\n    console.log(`ðŸ” First trying to match by entity_id: ${caseEntityId}...`);\n    satisfactionRecord = satisfactionRecordsById.get(caseEntityId);\n    \n    if (satisfactionRecord) {\n      console.log(`âœ… Found satisfaction match by entity_id: ${caseEntityId}`);\n    }\n  }\n  \n  // SECONDARY MATCHING: Fallback to entity_name if no match by entity_id\n  if (!satisfactionRecord) {\n    console.log(`ðŸ” No satisfaction match by entity_id, trying entity_name: ${entityName}...`);\n    satisfactionRecord = satisfactionRecords.get(entityName);\n    \n    if (satisfactionRecord) {\n      console.log(`âœ… Found satisfaction match by entity_name: ${entityName}`);\n    }\n  }\n  \n  // TERTIARY MATCHING: Last resort, try manual lookup through all satisfaction records\n  if (!satisfactionRecord) {\n    console.log(`ðŸ” No satisfaction match yet, trying manual lookup...`);\n    for (const [satEntityName, satRecord] of satisfactionRecords) {\n      if (satRecord.entity_id === entityName || satRecord.entity_id === caseRecord.entity_id) {\n        console.log(`âœ… Found satisfaction match by manual lookup: ${satRecord.entity_id} (satisfaction entity_name: ${satEntityName})`);\n        satisfactionRecord = satRecord;\n        break;\n      }\n    }\n  }\n  \n  console.log(`ðŸ”„ Merging data for: ${entityName}`, {\n    hasCaseData: !!caseRecord,\n    hasSatisfactionData: !!satisfactionRecord,\n    satisfactionSource: satisfactionRecord?.source,\n    satisfactionEntityName: satisfactionRecord?.entity_name,\n    satisfactionEntityId: satisfactionRecord?.entity_id\n  });\n  \n  // Create merged record with case performance as base\n  const mergedRecord = {\n    entity_id: caseRecord.entity_name || caseRecord.entity_id, // Use consistent entity identifier\n    entity_name: caseRecord.entity_name,\n    entity_type: caseRecord.entity_type,\n    date: caseRecord.date,\n    \n    // Merge metrics: case performance + satisfaction data\n    metrics: {\n      // Case performance metrics\n      sct: caseRecord.metrics?.sct || 0,\n      closedCases: caseRecord.metrics?.closedCases || 0,\n      \n      // Add satisfaction data if available\n      ...(satisfactionRecord?.metrics?.customerSatisfaction && {\n        customerSatisfaction: satisfactionRecord.metrics.customerSatisfaction\n      })\n    },\n    \n    // Case performance specific fields\n    cases_count: caseRecord.cases_count || 0,\n    sample_cases: caseRecord.sample_cases || [],\n    \n    // Survey details at root level (not in metrics)\n    surveyDetails: satisfactionRecord?.surveyDetails || null,\n    \n    metadata: {\n      ...caseRecord.metadata || {},\n      matchingMethod: satisfactionRecord \n        ? (satisfactionRecord === satisfactionRecordsById.get(caseEntityId) \n           ? \"entity_id_match\" \n           : (satisfactionRecord === satisfactionRecords.get(entityName)\n              ? \"entity_name_match\"\n              : \"manual_lookup_match\"))\n        : \"no_match\"\n    },\n    \n    // Timestamps - use most recent or case performance timestamps\n    created_at: caseRecord.created_at,\n    updated_at: caseRecord.updated_at || new Date(),\n    \n    // Source tracking\n    source: satisfactionRecord?.source ? \n      `${caseRecord.source || 'case-workflow'} + ${satisfactionRecord.source}` : \n      (caseRecord.source || 'case-workflow')\n  };\n  \n  mergedRecords.push(mergedRecord);\n  \n  console.log(`âœ… Merged record for ${entityName}:`, {\n    hasScMetrics: !!(mergedRecord.metrics.sct || mergedRecord.metrics.closedCases),\n    hasSatisfactionMetrics: !!mergedRecord.metrics.customerSatisfaction,\n    hasSurveyDetails: !!mergedRecord.surveyDetails,\n    casesCount: mergedRecord.cases_count,\n    sampleCasesCount: mergedRecord.sample_cases?.length || 0,\n    matchingMethod: mergedRecord.metadata.matchingMethod\n  });\n});\n\n// Handle satisfaction records that don't have corresponding case performance records\nsatisfactionRecords.forEach((satisfactionRecord, entityName) => {\n  if (!casePerformanceRecords.has(entityName)) {\n    console.log(`âš ï¸ SKIPPING Satisfaction-only record for: ${entityName} (no case performance data found)`);\n    console.log(`âŒ Available case performance entities:`, Array.from(casePerformanceRecords.keys()));\n    console.log(`âŒ This satisfaction entity: ${entityName} not found in case performance records`);\n    \n    // DO NOT CREATE satisfaction-only records - they cause excess data\n    // Instead, log the issue for debugging\n    console.log(`ðŸš« Not saving satisfaction-only record for ${entityName} to prevent excess data`);\n  }\n});\n\nconsole.log('ðŸŽ¯ Final merged records summary:', {\n  totalMergedRecords: mergedRecords.length,\n  entitiesWithBothData: casePerformanceRecords.size,\n  entitiesWithSatisfactionOnly: satisfactionRecords.size - casePerformanceRecords.size,\n  recordsWithSurveyDetails: mergedRecords.filter(r => r.surveyDetails !== null).length\n});\n\nif (mergedRecords.length > 0) {\n  console.log('ðŸ“‹ Sample merged record structure:', Object.keys(mergedRecords[0]));\n  console.log('ðŸ“Š Sample metrics keys:', Object.keys(mergedRecords[0].metrics));\n}\n\n// Return merged records for MongoDB insertion\nreturn mergedRecords.map(record => ({ json: record }));"
      },
      "id": "5fc15c5a-ba1e-49ab-be0d-ec6ad28c4d41",
      "name": "Process Aggregate Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        -96
      ]
    },
    {
      "parameters": {
        "operation": "insert",
        "collection": "performance_data",
        "fields": "entity_id, entity_name, entity_type, date, metrics, cases_count, sample_cases, surveyDetails, metadata, created_at, updated_at, source",
        "options": {}
      },
      "id": "9fdee56e-d505-47e2-bd6d-b19a7ea85911",
      "name": "Save Aggregate Data",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1,
      "position": [
        704,
        -96
      ],
      "credentials": {
        "mongoDb": {
          "id": "Pl29NJOEfuRbqWf6",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "id": "e77e26fa-f73a-4f4c-b411-cddb5cef7427",
      "name": "Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        928,
        -96
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Aggregate Data Trigger": {
      "main": [
        [
          {
            "node": "Process Aggregate Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Aggregate Data": {
      "main": [
        [
          {
            "node": "Save Aggregate Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Aggregate Data": {
      "main": [
        [
          {
            "node": "Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "9d350f55-ee2c-485f-8a1b-d135f0a73c2e",
  "meta": {
    "instanceId": "4ae47e0d2927c2ad6ce432ba64a316fc4b36f12b6aeb96b5fb893ad9ad8e6961"
  },
  "id": "QkTL13ss9wmvB2Fm",
  "tags": []
}